package Mrt::_Node;
use strict;
use warnings;
use Mrt::Util('trace');
use Data::Dumper;

sub new {
   my $classname  = shift;         # What class are we constructing?
	my $this  = {};                 # Allocate new memory 
   bless($this, $classname);       # Mark it of the right type
   
	$this->{id} = shift;
   $this->{parent_id} = shift;
   $this->{value} = shift;
   
   $this->{children} = [];
   return $this;
}

sub add_child {
	my $this = shift;
	my $node = shift;
	push @{$this->{children}}, $node;
}

sub to_string { my $this = shift; return $this->{id} . " " . $this->{parent_id} . "<br>\n" }
sub get_parent_id { my $this = shift; 	return $this->{parent_id};	 }
sub get_id { my $this = shift; 	return $this->{id}; }
sub get_value { my $this = shift; 	return $this->{value}; }
sub set_value { my $this = shift; $this->{value} = shift; }

#######################################################################

package Mrt::Tree;
use strict;
use warnings;
use Mrt::Util('trace');
use Data::Dumper;

sub new {
   my $classname  = shift;         # What class are we constructing?
	my $this  = {};                 # Allocate new memory 
   bless($this, $classname);       # Mark it of the right type
   
	$this->{lookup} = {};
	$this->{levels} = {};
   
   my $node = new Mrt::_Node('root','',''); # make root node. not visible. just holds all the others
   $this->{root} = $node;
   $this->{lookup}->{'root'} = $node;
   $this->{levels}->{'root'} = -1;
   
   
   return $this;                		# And give it back
}

sub get_level {
	my $this = shift;
	my $id = shift;
	return $this->{levels}->{$id} or trace "no such node: '$id'";
}

# gets id of the nodes parent on first level
sub get_first_level_id {
	my $this = shift;
	my $id = shift;
	my $node = $this->_get_node($id);
	while ($node->get_level() > 0) {
		$id = $node->get_parent_id($id);
		$node = $this->_get_node($id);
	}
	
	return $id;
}

sub get_child_ids {
	my $this = shift;
	my $id = shift;
	my $node = $this->_get_node($id);
	
	my @retval = ();
	foreach my $c (@{$node->{children}}) {		
		push @retval , $c->get_id();
   }
	return @retval;
}

sub get_value {
	my $this = shift;
	my $id = shift;
	my $node = $this->_get_node($id);
	return $node->get_value();
}

sub _get_parent {
	my $this = shift;
	my $id = shift;
	my $parent_id = $this->_get_node($id)->get_parent_id();
	return $this->_get_node($parent_id);	
}

sub is_first {
	my $this = shift;
	my $id = shift;
	my $node = $this->_get_node($id);
	my $parent = $this->_get_parent($id);
	return ($node == $parent->{children}->[0]);
}

sub is_last {
	my $this = shift;
	my $id = shift;
	my $node = $this->_get_node($id);
	my $parent = $this->_get_parent($id);
	return ($node == $parent->{children}->[-1]);
}

sub _get_node { # gets node by id
	my $this = shift;
	my $id = shift || 'root';
	my $node = $this->{lookup}->{$id} or trace("no such node: $id");
	return $node;
}

sub node_exists {
	my $this = shift;
	my $id = shift;
	return $this->{lookup}->{$id} ? 1 : 0;
}

sub add_node {
	my $this = shift;
	my $id = shift;
	my $parent_id = shift || 'root';
	my $value = shift;
	
	# print "$id - $parent_id<br>";
	
	my $parent = $this->_get_node($parent_id) or trace "no such parent: '$parent_id'";
	
	my $node = new Mrt::_Node($id, $parent_id, $value);
	$this->{lookup}->{$id} = $node;
	$this->{levels}->{$id} = $this->{levels}->{$parent_id} + 1;

	$parent->add_child($node);
}

sub get_ids { # returns all ids
	my $this = shift;
	my @keys = grep { $_ ne 'root' } keys %{$this->{lookup}};
	return @keys;
}

sub get_ordered_ids { # returns arrayref of depth first ordered ids
   my $this = shift;
	my $node = shift; # hash ref with options on first call - node on recursive ones
	my $ids = shift || [];
	my $id_to_skip = shift || '';

	if (! defined $node) {
		$node = $this->{lookup}->{'root'};
	}
	
	if (ref $node eq 'HASH') {
		$id_to_skip = $node->{no_descendants};	
		$node = undef;
	}

	foreach my $n (@{$node->{children}}) {
		next if ($n->{'id'} eq $id_to_skip);
		push @$ids, $n->{'id'};
		$this->get_ordered_ids($n, $ids, $id_to_skip);
   }
	
	return $ids;
}

sub get_descendant_ids {
	my $this = shift;
	my $id = shift;
	my $n = $this->_get_node($id);
	return $this->get_ordered_ids($n, []);
}

sub dump_tree {
   my $this = shift;
   my $id = shift;
	my $node = $this->{lookup}->{($id || 'root')} or trace "no such node: '$id'";
	
	foreach my $c (@{$node->{children}}) {		
		my $level = $this->{levels}->{$c->get_id()};
		print "&nbsp;&nbsp;&nbsp;" x $level;
		print $level," - ",$c->get_id(),"<br>";
		$this->dump_tree($c->get_id());
   }
}

1;